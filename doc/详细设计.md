# 详细设计

## 目录

- [详细设计](#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1)
    - [目录](#%E7%9B%AE%E5%BD%95)
    - [功能实现](#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0)
        - [IO](#io)
        - [串口](#%E4%B8%B2%E5%8F%A3)
        - [Modbus](#modbus)
        - [OpcUa](#opcua)
    - [总体方案](#%E6%80%BB%E4%BD%93%E6%96%B9%E6%A1%88)
        - [系统总体层级设计](#%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E5%B1%82%E7%BA%A7%E8%AE%BE%E8%AE%A1)
        - [系统接口设计](#%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1)
            - [硬件接口](#%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3)
            - [后端接口](#%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3)
            - [前端接口](#%E5%89%8D%E7%AB%AF%E6%8E%A5%E5%8F%A3)
    - [模块详细设计](#%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1)

## 功能实现

### IO

可以对IO做配置，可以配置的内容有:
1. 总共16个GPIO口的输入输出设置。
1. 输入IO的最低有效脉冲时间。
1. 输出IO的高低电平持续时间，可以设置常高或常低。
1. 在输入为高或低的情况下，执行一些动作(优先度低)，比如
    1. 修改其他IO的状态
    1. 发送串口数据
    1. 修改Modbus参数
    1. 修改OpcUa参数
1. 界面按钮可以直接控制高低

### 串口

1. 可以设置每个串口的波特率，停止位，校验位。
1. 可以设置ASCII模式还是整数模式，在ASCII模式下发送的信息包括数字都是ASCII码，在整数模式下只能发送数字。
1. 可以设置串口每隔一定时间发送设置好的信息。
1. 可以设置串口在接收到某个数据时发送对应设置好的数据。

### Modbus

1. 支持ModBusRTU和ModBusTCP。
1. 可以设置任意数量的从机地址(slave)，每个从机地址都可以分别进行设置。
1. 功能码支持线圈读写(1、5、15)，设置离散输入状态(2)，读写保持寄存器(3、6、16)，读取输入寄存器(4)。
1. 可以对各个数据进行设置，可设置数据的变化趋势和间隔。(后期更改为设置这个数据的变更条件和变更目标值和增量)。
1. 从机上已设置寄存器数据展示，按照地址从小到大顺序展示。
1. 从机上线圈和离散输入状态开关展示。

### OpcUa

1. 设置IP和端口
1. 设置节点地址和数值
1. 可以对各个数据进行设置，可设置数据的变化趋势和间隔。(后期更改为设置这个数据的变更条件和变更目标值和增量)。
1. 界面上已设置的节点和数据展示。

## 总体方案

### 系统总体层级设计

![接口测试系统详细设计](img/详细设计-接口测试系统架构设计.png)

### 系统接口设计

#### 硬件接口

GPIO口有16个，可以通过导入Rpi.GPIO来使用，接口参数包括:

| 功能             | 接口           | 参数                                         |
| ---------------- | -------------- | -------------------------------------------- |
| 设置gpio的模式   | GPIO.setmode() | 模式名                                       |
| 设置gpio口的参数 | GPIO.setup()   | 接口名，输入输出设置，上下拉设置(一般in需要) |
| 获取输入数据的值 | GPIO.input()   | GPIO口编号                                   |
| 对gpio口赋值     | GPIO.output()  | gpio口编号，电压值                           |

串口在树莓派板卡上只有一个，但是可以通过USB口扩展，或直接控制GPIO口作为串口使用，可以通过导入pyserial来支持串口，接口包括:

| 功能         | 接口            | 参数                                       | 备注 |
| ------------ | --------------- | ------------------------------------------ | ---- |
| 串口的实例   | serial.Serial() | port，baudrate，parity，stopbits，bytesize |      |
| 读取串口数据 | ser.read()      | 读取数据的数量                             |      |
| 写入串口数据 | ser.write()     | 换行符需要转换为ASCII                      |      |

* 在串口延时有问题时，可以设置串口的timeout属性，用来设置最大读取延时。另外使用writeTimeout用来设置写入延时。

modbus协议可以通过串口(ModbusRTU)和网口(ModbusTCP)来进行通信，可以通过导入modbus_tk来实现相关协议，在使用时除进行实例化时所用的接口不同外，其他用法均相同，接口如下:

| 功能        | 接口                                      | 参数                                 | 备注 |
| ----------- | ----------------------------------------- | ------------------------------------ | ---- |
| 添加RTU服务 | modbus_rtu.RtuServer(serial.Serial(PORT)) | 串口实例                             |      |
| 添加TCP服务 | modbus_tcp.TcpServer()                    | 无                                   |      |
| 添加从机    | server.add_slave()                        | 从机名称或编号                       |      |
| 添加数据块  | slave.add_block()                         | 数据块名称，功能，开始地址，结束地址 |      |
| 写入数据    | slave.set_values()                        | 数据块名称，开始地址，数据           |      |
| 读取数据    | slave.get_values()                        | 数据块名称，开始地址，读取地址数量   |      |

#### 后端接口

#### 前端接口


## 模块详细设计

